import { IBoardState } from './board-interface';
import { ProfloAgileActionTypes } from './action';
import { IColumn } from './column-interface';
import { IAction } from './action-interface';
import { ITask } from './task-interface';

export const INITIAL_STATE: IBoardState = {
    id: '',
    sprintId: '',
    productId: '',
    productName: '',
    sprintName: '',
    columns: []
};
let currentColumn: IColumn = {
    id: '',
    columnName: '',
    tasks: []
};
let columns = [];
let previousColumn: IColumn = {
    id: '',
    columnName: '',
    tasks: []
};
let stateColumns = [];
let newColumn;

function moveItemInArray(array: ITask[], previousPosition: number, currentPosition: number) {
    if (currentPosition >= array.length) {
        let k = currentPosition - array.length + 1;
        while (k--) {
            array.push();
        }
    }
    array.splice(currentPosition, 0, array.splice(previousPosition, 1)[0]);
    return array;
}

function transferArrayItem<T = any>(currentArray: T[], targetArray: T[], currentIndex: number, targetIndex: number): void {
    const movedTask = currentArray.splice(currentIndex, 1);
    targetArray.splice(targetIndex, 0, movedTask[0]);
}
export function rootReducer(state: IBoardState, action: IAction) {
    console.log('inside the reducer****', state);
    switch (action.type) {
        case ProfloAgileActionTypes.UPDATE_STATE:
            return Object.assign({}, state, {
                id: '1',
                sprintId: '1',
                productId: '1',
                productName: 'Naman Shrimali Kanban',
                sprintName: 'Sprint One',
                columns: action.payload
            });
        case ProfloAgileActionTypes.MOVE_CARD_WITHIN_COLUMN:
            // payload :: columnId, previousTaskPosition, currentTaskPosition
            columns = JSON.parse(JSON.stringify(state.columns));
            currentColumn = columns.find((columnWithin: IColumn) => columnWithin.id === action.payload.columnId);
            moveItemInArray(currentColumn.tasks, action.payload.previousTaskPosition, action.payload.currentTaskPosition);
            const indexOfColumn = columns.indexOf(currentColumn);
            newColumn = [];
            newColumn = [
                ...state.columns.slice(0, indexOfColumn),
                currentColumn,
                ...state.columns.slice(indexOfColumn + 1, state.columns.length + 1)
            ];
            return Object.assign({}, state, {
                columns: newColumn
            });

        case ProfloAgileActionTypes.MOVE_CARD_ACROSS_COLUMN:
            // payload :: previousColumnId, currentColumnId, previousTaskPosition, currentTaskPosition
            stateColumns = JSON.parse(JSON.stringify(state.columns));
            previousColumn = stateColumns.find((iteratedPreviousColumn: IColumn) =>
                iteratedPreviousColumn.id === action.payload.previousColumnId);

            currentColumn = stateColumns.find((iteratedCurrentColumn: IColumn) =>
                iteratedCurrentColumn.id === action.payload.currentColumnId);
            transferArrayItem(
                previousColumn.tasks, currentColumn.tasks, action.payload.previousTaskPosition, action.payload.currentTaskPosition
            );
            return Object.assign({}, state, {
                columns: stateColumns
            });
        case ProfloAgileActionTypes.CARD_COMPLETED:
            // payload :: previousColumnId, previousTaskPosition, currentTaskPosition, currentColumnId
            return Object.assign({}, state, {
            });
        // case UPDATE_CARD:
        case ProfloAgileActionTypes.ADD_COLUMN:
            // payload :: column object
            // to be filled :: action.payload.columnId
            action.payload.column.tasks = [];
            return Object.assign({}, state, {
                columns: state.columns.concat(Object.assign({}, action.payload.column))
            });
        case ProfloAgileActionTypes.DELETE_COLUMN:
            // payload :: columnIndex
            return Object.assign({}, state, {
                columns: state.columns.filter((columnForDeletion: IColumn) =>
                    state.columns.indexOf(columnForDeletion) !== action.payload.columnIndex)
            });
        case ProfloAgileActionTypes.MOVE_COLUMN:
            console.log(state);
            // console.log(JSON.parse(JSON.stringify(state)));
            console.log(action.payload);
            newColumn = [];
            if (action.payload.currentColumnIndex > action.payload.previousColumnIndex) {
                newColumn = [
                    ...state.columns.slice(0, action.payload.previousColumnIndex),
                    ...state.columns.slice(action.payload.previousColumnIndex + 1, action.payload.currentColumnIndex + 1),
                    ...state.columns.slice(action.payload.previousColumnIndex, action.payload.previousColumnIndex + 1),
                    ...state.columns.filter((element) => {
                        if (state.columns.indexOf(element) > action.payload.currentColumnIndex) {
                            return element;
                        }
                    })
                ];

            } else {
                newColumn = [
                    ...state.columns.slice(0, action.payload.currentColumnIndex),
                    ...state.columns.slice(action.payload.previousColumnIndex, action.payload.previousColumnIndex + 1),
                    ...state.columns.filter((element) => {
                        if (state.columns.indexOf(element) > action.payload.currentColumnIndex - 1 &&
                            state.columns.indexOf(element) !== action.payload.previousColumnIndex) {
                            return element;
                        }
                    })
                ];
                console.log(state);
                console.warn(newColumn);
            }
            return Object.assign({}, state, {
                columns: newColumn
            });
        case ProfloAgileActionTypes.EDIT_COLUMN_TITLE:
            // payload :: columnIndex, newName
            const column = state.columns[action.payload.columnIndex];
            column.columnName = action.payload.newName;
            return Object.assign({}, state, {
                columns: [...state.columns.slice(0, action.payload.columnIndex),
                Object.assign({}, column, { columnName: action.payload.newName }),
                ...state.columns.slice(action.payload.columnIndex + 1)
                ]
            });
    }
    return state;
}
